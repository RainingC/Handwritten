// 原理是生成器gen
// 1、在async函数中，遇到await的时候，会生成一个promise_，把await后面的语句放到这个promise_的主体中去执行，promise内部的executor开始执行，同时把权限交回给父协程（原理是调用了生成器的yeild）
// 这个过程，如果await后面是同步代码，会直接执行resolve，但JS会把它推到微队列中，等待回调正常绑定后再触发。   如果是异步代码，则正好直接推到微队列中等待执行

// 2、父协程拿到权限后，调用promise_.then来监听这个promise的回调。并继续执行后续代码（也就是async函数后面的代码，暂时跳过async函数的执行）。（可以理解为.then里存放着await语句前的赋值操作，和后续代码如let a = await ***）

// 3、父协程的同步代码执行完毕后，检查微队列，发现有回调函数。则执行：触发resolve（如果是请求接口，则等待接口返回后）将参数value返回给。也就是触发了promise_.then绑定的回调函数，回调函数中会将控制权交回给子协程，同时拿到resolve返回的value。

// 4、子协程得到权限，将刚才拿到的value赋值或执行其他语句，然后继续执行async函数中的剩余代码。子协程的所有代码执行完毕后，自动将控制权交回给主协程